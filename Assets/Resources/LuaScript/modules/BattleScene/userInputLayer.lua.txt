---处理用户输入的层，主要事件的监听，与事件的分发
---完整的data全部都存放在dll中
---@class UserInputLayer
local M = {}

---在这一层里面处理所有的用户输入与输出

---@param script Scene.CombatScene.CombatPanelSlotScript 这个是存放有卡牌的slot脚本
function M.slotReleaseEvent(script)
    ---主要针对点击卡牌后移动鼠标，将卡牌放置到当前的位置上的事件
    
    ---@type Scene.CombatScene.UserInputScript
    local input = CS.Scene.CombatScene.UserInputScript.GetCurUserInput()
    local panel = input:GetPanel(input:GetCurSlotPlayerId())
    ---@type Prefab.CombatSceneCombatCardScript
    local curCard = input.dragCardTransform:GetComponent(typeof(CS.Prefab.CombatSceneCombatCardScript))
    if curCard then
        return
    end
    if (panel ~= nil) then
        ---这个是鼠标当前所在的slot
        local slot = panel:GetSlot(input:GetCurSlotIndex())
        if slot then
            if (slot:HasCard()) then ---目标槽位上不能有卡牌
                CS.Global.MakeToast("当前卡槽已被占用!", CS.Global.TOAST_LONG);
            elseif(script:HasCard()) then   ---要求当前槽位上有卡牌存在
                ---玩家只能卡牌放置到自己的槽位上
                ---感觉需要从战斗场景的数据中取得玩家的id
                if slot:GetPlayer() == input.myPanel.PlayerId then
                    slot:AddCard(script:Remove())
                else
                    
                end
            else

            end
        end
    end
end

---@param card Prefab.CombatSceneCombatCardScript
---@param data UnityEngine.EventSystems.PointerEventData
function M.mouseClickPawnUp(card, data, long)
    ---玩家触发卡牌的点击事件后的函数
    ---接下来将当前卡牌对位的卡牌设置为目标，如果没有，则将敌方玩家设置为目标对象
    ---并弹出是否确认发动攻击的按钮，如果玩家点击确认则发动攻击
    if long then
        log("长按的事件")
		---长按的后显示当前点击的卡牌的详细信息
		if showDetail then
			showDetail()
		end
    else
		log("短按的事件")
        ---短按的事件
		---这里做玩家是否发动攻击指令的判定
		---这里需要能够获取到卡牌的uid
    end
    
    --M.mouseDragHandCardEnd()
end

---@param this Prefab.CombatSceneCombatCardScript
function M.mouseClickPawn(this, data)
    ---只有在棋盘中的卡牌才能发动攻击
    ---其他的判定都交给自己去做
    if this:InCombat() then
        M.attack(this.uid)
    end
end

---@param this Prefab.CombatSceneCombatCardScript
function M.mouseDragEnd(this)
    M.mouseDragHandCardEnd(this)
end

---@param this Prefab.CombatSceneCombatCardScript
function M.mouseDragHandCardEnd(this)
    ---@type Scene.CombatScene.UserInputScript
    local input = CS.Scene.CombatScene.UserInputScript.GetCurUserInput()
    local panel = input:GetPanel(input:GetCurSlotPlayerId())
    local slot = panel:GetSlot(input:GetCurSlotIndex())
    if slot and this and not slot:HasCard() then
        --print(slot:AddCard(this))
        GamePlay.cur():summon(GamePlay.cur():getPlayer(), this.uid, tonumber(string.match(slot.name, "%w+(%d)")))
    end
    log("当前选择的卡牌对象的父对象名称为:".. this.transform.parent.name)
end

function M.turnEnd()
    -- log"玩家回合结束"
    -- if GamePlay and GamePlay.cur() then
    --     GamePlay.cur():getHandle().turnEnd()
    -- end

    if GamePlay then
        local gameplay = GamePlay.cur()
        if gameplay then
            -- gameplay:getHandle().turnEnd(gameplay:getHandle().getPlayer())
            gameplay:turnEnd(gameplay:getPlayer())
        end
    end
end

function M.drawNormal()
    -- log"抽取一张普通卡牌"
    -- if GamePlay and GamePlay.cur() then
    --     GamePlay.cur():getHandle().draw(1, false)
    -- end
    if GamePlay then
        local gameplay = GamePlay.cur()
        if gameplay then
            -- gameplay:getHandle().draw(gameplay:getHandle().getPlayer(), 1, false)
            gameplay:draw(gameplay:getPlayer(), 1, false)
        end
    end
end

function M.drawHigh()
    -- log"抽取一张高级卡牌"
    -- if GamePlay and GamePlay.cur() then
        -- GamePlay.cur():getHandle().draw(1, true)
    -- end
    if GamePlay then
        local gameplay = GamePlay.cur()
        if gameplay then
            -- gameplay:getHandle().draw(gameplay:getHandle().getPlayer(), 1, true)
            gameplay:draw(gameplay:getPlayer(), 1, true)
        end
    end
end

function M.useSkill(pawn, target, skillId)
    if GamePlay then
        local gameplay = GamePlay.cur()
        if gameplay then
            -- gameplay:getHandle().userSkill(gameplay:getHandle().getPlayer(), pawn, target, skillId)
            gameplay:useSkill(gameplay:getPlayer(), pawn, target, skillId)
        end
    end
end

---从当前玩家的手牌中将一枚棋子拖动到自己的棋盘上时触发
function M.summon(pawnId, pos)
	--- 玩家拖拽手中的卡牌，释放鼠标的时候检测当前鼠标是否在某个卡槽的上方，如果在的话，则进行下一步逻辑
    -- log"召唤一枚棋子"
    -- if GamePlay and GamePlay.cur() then
    --     GamePlay.cur():getHandle().summon(pawnId, pos)
    -- end

    if GamePlay then
        local gameplay = GamePlay.cur()
        if gameplay then
            -- gameplay:getHandle().summon(gameplay:getHandle().getPlayer(), pawnId, pos)
            gameplay:summon(gameplay:getPlayer(), pawnId, pos)
        end
    end
end

function M.attack(uid)
    -- log"棋子发动攻击"
    -- if GamePlay and GamePlay.cur() then
    --     GamePlay.cur():getHandle().attack(uid)
    -- end

    if GamePlay then
        local gameplay = GamePlay.cur()
        if gameplay then
            gameplay:attack(gameplay:getPlayer(), uid)
        end
    end
end

function M.init()
    ---@type Scene.CombatScene.UserInputScript
    M.inputLayer = nil
    ---@type Scene.CombatScene.CombatPanelSlotScript
    M.curHonverSlot = nil
    
    ---@type DisplayPawn[]
    global.cardInfos = global.cardInfos or json.decode(CS.Util.Loader.Read("LuaScript/json/cards"))
    local go = CS.UnityEngine.GameObject.FindGameObjectWithTag("UserInput")
    if go then
        M.inputLayer = go:GetComponent(typeof(CS.Scene.CombatScene.UserInputScript))
		--- 监听鼠标在卡牌的slot上释放的事件
        CS.Lib.Listener.Instance:On("Release_Slot", M.slotReleaseEvent, go, 0, false)
		--- 监听鼠标弹起的事件
		CS.Lib.Listener.Instance:On("Mouse_Click_Pawn_Up", M.mouseClickPawnUp, go, 0, false)
        --- 快速点击目标棋子后，该棋子做出攻击的动作
        CS.Lib.Listener.Instance:On("Mouse_Click_Pawn", M.mouseClickPawn, go , 0, false)
        --- 
        CS.Lib.Listener.Instance:On("Mouse_Drag_Pawn_End", M.mouseDragEnd, go, 0, false)
    end
    
    --region
	--这一段代码就是进入战斗场景之后，初始化场地上所有的卡牌的代码
    --这里就是通过本地数据来初始化战场中相关信息的
    --是一段测试代码
    -- ---@type Scene.CombatScene.UserInputScript
    --local script = go:GetComponent(typeof(CS.Scene.CombatScene.UserInputScript))
    --for i = 0, #(M.data.myPanel) - 1 do
    --    local index = M.data.myPanel[i + 1]
    --    if index and index ~= 0 then
    --        local origin = CS.Util.Loader.Load("Prefab/CombatPawn")
    --        ---@type UnityEngine.GameObject
    --        local card = CS.UnityEngine.GameObject.Instantiate(origin)
    --        --card.transform.localPosition = CS.UnityEngine.Vector3.zero
    --        ---@type UnityEngine.RectTransform
    --        local tr = card:GetComponent(typeof(CS.UnityEngine.RectTransform))
    --        tr.localPosition = CS.UnityEngine.Vector3.zero
    --        ---@type Prefab.CombatSceneCombatCardScript
    --        local s = card:GetComponent(typeof(CS.Prefab.CombatSceneCombatCardScript))
    --        s.content.sprite = util.loadSprite("Image/Card/"..global.cardInfos[M.data.uids[index]].img)
    --        script.myPanel:GetSlot(i):AddCard(s)
    --        ---在最后修改创建出来的卡牌的缩放
    --        tr.localScale = CS.UnityEngine.Vector3(0.5, 0.5, 1)
    --    else
    --        script.myPanel:GetSlot(i):Remove()
    --    end
    --end
    --endregion

end

---还需要做的预制体有：卡牌的背面
---

return M