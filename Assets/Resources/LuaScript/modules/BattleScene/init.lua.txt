local M = {}

--local queryCard = require"modules.BattleScene.QueryCard"
local drawAndGold = require"modules.BattleScene.DrawAndGold"
--local helper = require"modules.BattleScene.CombatPawn"

---战斗场景应该具有的功能
---     异步加载(当场景中所有需要的数据全部加载完成的时候，发送消息给服务端，然后等待所有的客户端都加载完成之后，服务端发送消息，所有的客户端进入战斗场景)
---     

---这个是玩家点击左上角的设置按钮后的逻辑
---应该弹出一个ui，这个ui里面可以调整当前游戏里面的一些设置
---@param this UnityEngine.Transform
local function Setting(this)
    util.bindButtonCallback(this, function ()
        log("您点击了设置按钮")
    end)
end

local list = {
    --QueryCard = queryCard,
    DrawAndGold = drawAndGold,
    Setting = Setting
}

---@param data number[]
function M.init(data)
    global.config = json.decode(util.read("LuaScript/json/global"))
	require"modules.BattleScene.LoadingLayer".init()
	local handle = require"modules.BattleScene.MsgHandle"
    ---这一块只做视图相关的处理，以及玩家输入后对combat的调用
    GamePlay = GamePlay or require"gameplay.init"
    GamePlay.create("default")
    ---绑定两个函数，处理cpp core回传的数据
    GamePlay.cur().bindUpdate(handle.distribute)
    GamePlay.cur().bindNotice(handle.notice)
    
    ---@type DefaultGamePlay
    local gamePlay = GamePlay.cur()
    if global.deckCards then
        ---加载当前玩家所有的卡牌、资源等
        gamePlay:start(global.deckCards)
        -- -通过这个获取到当前玩家的数据

        ---现在 CS.LuaApi.GetPlayer(1, 1) 这个api有问题，不知道为什么之前可以运行，后来就会导致游戏崩溃
        ---这个是通过某种手段获取到的当前玩家的卡牌数组
        ---这里获取到当前玩家的卡牌数据
        --local t = CS.LuaApi.GetPlayer(GamePlay.cur():getCombatId(), GamePlay.cur():getPlayer())
        local t = GamePlay.cur():getPawnList()
        -- nn.get_combat()
        ---@type CCard[]
        global.combatCardInfos = {}
        local imgs = {}
        for i = 1, 100 do
            ---在lua端组合出完整的卡牌数据
            ---这里的两个数组里面的信息是一一对应的，
            
            ---这里需要做一个转换，因为cs、cpp的数组下标都是从0开始
            local e = t[i]
            table.insert(imgs, string.format("Image/Card/%s", global.cardInfos[e].img))
            table.insert(imgs, string.format("Image/Card/%s", global.cardInfos[e].icon))
        end
        
        --region
        ---需要能够获取到当前玩家所有的卡牌数据
        ---需要加载的资源应该有卡牌的图片资源、icon资源、技能的icon资源、如果有模型的话还需要加载模型等
        --local imgs = {}
        ---- local icons = {}
        --for i = 0, 49 do
        --    local card = t.cards[i];
        --    local obj = global.cardInfos[card]
        --    table.insert(imgs, obj.img)
        --    table.insert(imgs, obj.icon)
        --end
        --endregion
        
        -- log(json.encode(imgs))
        ---@type UnityEngine.GameObject
        local go = util.loadGameObject("Prefab/CombatPawn")
        ---这个接口还没有实现，先不管
        --CS.Util.Pool.SetMaxSize("CardImgs", 40)
        local function load()
            ---@type UnityEngine.Object
            local objs
            local res
            res, objs = xutil.async_to_sync(xutil.bind(CS.Util.Loader.LoadAsync, imgs))()
            if res then
                CS.Util.Pool.SetMaxSize("CardImgs", 40)
                ---数组长度为100
                ---偶数为卡牌的大图、奇数为卡牌的小图
                for i = 0, 99 do
                    ---实例化卡牌，并存入到pool中
                    if i % 2 == 0 then
                        ---应该提供一个专门的函数来生成不同的卡牌对象
                        ---对象池应该有可以设置最大值的接口
                        local card = CS.UnityEngine.GameObject.Instantiate(go)
                        ---这里加载的是大图
                        CS.Util.Pool.Store("CardImgs", card)
                    else
                        ---这里加载的是小图
                        ---CS.Util.Pool.Store("CardIcons")
                    end
                end
                ---游戏正式开始的时候再去调用这个函数，但是目前的情况来看的话，当前客户端所需的资源全部加载完成之后就可以调用这个函数了
                GamePlay.cur():combatStart()
            end
        end
        xutil.coroutine_call(load)()
    else
        --error"无效的卡牌数据"
		log"无效的卡牌数据"
    end
    
	require"modules.BattleScene.userInputLayer".init()
	require"modules.BattleScene.fGUICombat".init()
	
    ---离开场景的时候界面中要用到的数据会保留下来，但是ui会被销毁，下次再使用的时候再创建出来
    util.loadChild(CS.Global.GetCurCanvas().transform, list)
    
	--region
    ---以前检测的到卡牌，现在检测不到，很难受
    ---所有的卡牌的点击事件
    ---CS.Lib.Listener.Instance:On(CS.Lib.Listener.MOUSE_EVENT, function (a, b, c)
    ---    ---@type UnityEngine.RaycastHit
    ---    local isHit, hit = a:ExplicitRayHit()
    ---        ---- log("123123123")
    ---    if isHit then
    ---        ---判断当前点击的卡牌是否是自己的卡牌，如果是自己的卡牌，则会触发攻击相关的操作
    ---        ---如果不是自己的卡牌，则没有任何提示
    ---        ---如果持续点击对应的卡牌，则会显示当前卡牌的详细信息
    ---        if hit then
    ---            log(hit.transform.name)
    ---        end
    ---    end
    ---end, nil, CS.Lib.KeyCode.Mouse0, false)
	--endregion
end

return M