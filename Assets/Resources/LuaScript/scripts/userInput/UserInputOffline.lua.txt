---离线模式的处理方式，调用导出函数来完成
---@class UserInputOffline : IUserInput
local M = {}

---要如何才能实现ai相关的功能？
---感觉ai不能直接复用这边的逻辑

---当前回合中已经发动攻击了的棋子列表
---每个回合会重置这个
M._list = {}
---全局的当前玩家的id
playerId = playerId or 1
---全局的房间id
combatId = combatId or 1

---在cpp端应该有各个流程的导出

--region
--战斗相关的设定
--     1、攻击
--         每回合，每个棋子最多只能攻击一次，如果有特殊机制，需要做特殊处理
--         攻击目标棋子后，目标棋子也会对当前棋子发动一次攻击
--         玩家点击棋子之后，向上滑动一段距离后触发攻击的事件
--     2、使用技能
--         点击棋子身上的技能图标后先判定当前棋子是否能够使用技能，如果能使用技能的话，则要求选择技能的对象，选择技能的对象也满足要求的话，则释放技能      
--             在此期间，都会显示一个取消的按钮，如果玩家点击取消按钮的话，则结束当前使用技能的流程
--     3、结束当前回合
--         只有当前正在行动的玩家可以点击这个按钮，点击后结束当前回合，进入下个回合。 非当前玩家回合的情况下隐藏这个按钮?
--     4、点击抽卡
--         玩家点击两种不同的抽卡按钮，先判定是否有足够的金币，如果没有则提示金币不足，如果足够的话则调用抽奖
--     5、召唤棋子
--         玩家拖动手中的棋子到棋盘中将其召唤到对应的位置上，如果目标位置上已经存在棋子了，则失败，另外，玩家召唤棋子是需要一定的能量的
--endregion

---玩家选择棋子攻击
---如何判定玩家想要触发攻击事件？
---玩家点击自己棋盘上本回合没有攻击过的棋子，向上滑动指定个像素后，向目标位置上发动攻击，如果目标位置上没有棋子，则直接对目标玩家发动攻击
---@param attacker number 要发动攻击的棋子的uid
function M.attack(attacker)
    if M._list[attacker] then
        ---该棋子已经发动过攻击了，无法攻击
        ---这里应该提示无法再次攻击
        CS.Global.MakeToast("该回合此棋子不能再次攻击", CS.Global.TOAST_SHORT);
        return 
    end
    ---@type Combat
    local combat = nn.get_combat(combatId)
    local attackPawn = combat:getPawnByUid(attacker)
    if attackPawn:attack() > 0 then
        M._list[attackPawn:unique_id()] = true
        --- attackPawn:opHp()
        --- 当前发动攻击的棋子也受到目标棋子的攻击力的伤害
        local enemy = combat:getEnemy(combat:getWorkPlayer()):getCombatPawnByIndex(attackPawn:pos())
        local damage = Damage.new(false, atk, 1, enemy, attackPawn)
        --- opHp与hit相比较区别在于hit会走受伤的逻辑，而ophp是单纯的增减血量
        attackPawn:hit(damage);
    end
end

---玩家点击结束当前回合
function M.turnEnd()
    local combat = nn.get_combat(combatId)
    local curPlayer = combat:getWorkPlayer()
    -- nn.get_combat(combatId):turnEnd(playerId)
    if curPlayer:uid() == playerId then
        combat:turnEnd(playerId)
    else
        CS.Global.MakeToast("不是你的回合", CS.Global.TOAST_SHORT);
    end
end

---玩家选择棋子对目标使用技能
function M.userSkill(pawnId, targetId, skillId)
    local combat = nn.get_combat(combatId)
    local pawn = combat:getPawnByUid(pawnId)
    local target = combat:getPawnByUid(targetId)
    if not pawn:useSkillWithCost(target, skillId) then
        ---条件不足，无法使用该技能
        CS.Global.MakeToast("条件不足，无法使用该技能", CS.Global.TOAST_SHORT);
    end
end

---玩家点击抽取卡牌按钮
---玩家的抽卡其实只会抽一张卡，所以这里的数量其实默认为1
function M.draw(number, high)
    local gold = nil
    if high then
        gold = config.highPrice * number
    else
        gold = config.normalPrice * number
    end
    local combat = nn.get_combat(combatId)
    local player = combat:getPlayer(playerId)
    if player:gold() >= gold then
        player:draw(number, high)
    else
        ---金币不足，无法抽取新的棋子
        CS.Global.MakeToast("金币不足", CS.Global.TOAST_SHORT);
    end
end

---玩家召唤棋子
function M.summon(pawnId, pos)
    local combat = nn.get_combat(combatId)
    local player = combat:getPlayer(playerId)
    ---召唤棋子需要能量，
    local energy = player:energy()
    if player:getCombatPawnByIndex(pos) then
        ---目标位置上已经存在棋子了
        CS.Global.MakeToast("不能放置多枚棋子", CS.Global.TOAST_SHORT);
        return
    end
    ---这里的这个2应该是从配置文件中来
    if energy >= 2 then
        player:opEnergy(-2)
        player:summon(pawnId, pos)
    else
        ---能量不足，无法召唤棋子
        CS.Global.MakeToast("能量不足，无法召唤", CS.Global.TOAST_SHORT);
    end 
end

return M